# 518.零钱兑换||

思路：

一维数组动态规划

<img width="1205" height="766" alt="image" src="https://github.com/user-attachments/assets/cd9e5126-f73c-4a33-9512-a60f9de0c1f9" />

图中的滚动更新过程可以类比爬楼梯来理解，例如dp[4] = dp[4] + dp[2] 原dp[4]是硬币种类只用一块时的方法数，dp[2]是这一轮用上两块钱的方法数，新dp[4]是两轮加起来更新后的

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        // 创建动态规划数组，dp[j]表示凑成金额j的方法数
        // 数组大小为amount+1，因为需要考虑从0到amount的所有金额
        vector<int> dp(amount + 1, 0); // 全部初始化为0；

        // 初始化：凑成金额0的方法只有1种（什么都不选）
        dp[0] = 1;

        // 外层循环：遍历每一种硬币
        // 注意：这里必须先遍历硬币，再遍历金额
        // 这样才能保证组合数（不是排列数）
        for (int coin : coins) {
            // 内层循环：遍历所有可能的金额
            // 从当前硬币面值开始，因为小于硬币面值的金额无法使用当前硬币
            for (int j = coin; j <= amount; j++) {
                // 递推公式
                // 凑成金额j的方法数 = 原来的方法数 + 使用当前硬币的方法数
                // dp[j - coin] 表示凑成剩余金额 j-coin 的方法数
                // 使用当前硬币后，还需要凑成 j-coin 的金额
                dp[j] += dp[j - coin];
            }
        }

        return dp[amount];
    }
};
```
