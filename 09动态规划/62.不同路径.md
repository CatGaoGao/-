# 62.不同路径

力扣链接：https://leetcode.cn/problems/unique-paths/

---

直接看的讲解视频，二维的就是多了一层for循环嵌套，初始化的时候也要注意

---

**思路：**

1. **dp[i][j]含义：** 到达 (i,j) 位置的走法数量，**i,j** 含义：(i,j) 位置   
2. **递推公式** dp[i][j] = dp[i-1][j] + dp[i][j-1] 走到(i,j)位置，无非就是从 上移一格 或者 左移一格 的位置移动过来（题目说只能向下/右走），故而到(i,j)就是二者相加
3. **初始化** dp[i][0] = 1, dp[0][j] = 1; 只能向下/右走，故而在起始行/列的格子，从起始点开始，都只有一种走法
4. **遍历顺序** 从上往下。从左往右遍历

---

## 代码

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0)); // 定义二维

        // 初始化，因为只能向下、向右走
        for(int i = 0 ; i < m ; i++){
            dp[i][0] = 1;
        }
        for(int j = 0 ; j < n ; j++){
            dp[0][j] = 1;
        }

        // 从上向下，从左往右遍历
        for(int i = 1 ; i < m ; i++){
            for(int j = 1 ; j < n ; j++){
                // 递归公式
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1]; // 注意数组的有效位置
    }
};
```
