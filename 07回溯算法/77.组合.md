# 77.组合

力扣链接：https://leetcode.cn/problems/combinations/

---

试图边补卡边同步跟一下，同时还看hot100，明天一定要把项目开始

---

<img width="1303" height="770" alt="image" src="https://github.com/user-attachments/assets/2f9c1fdc-05ae-4cb2-863e-91002d5b95f8" />

**思路：**

1. **框架**    
```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

2. **整体**   

注意此处定义的两个vector，之所以定义在回溯的函数前，是作为一个全局的变量比较方便

```cpp
vector<vector<int>> result; // 存放符合条件结果的集合
vector<int> path; // 用来存放符合条件单一结果
void backtracking(int n, int k, int startIndex)
```
**终止条件**      
```cpp
if (path.size() == k) {
    result.push_back(path);
    return;
}
```

3. **回溯**   
```cpp
for (int i = startIndex; i <= n; i++) { // 控制树的横向遍历
    path.push_back(i); // 处理节点
    backtracking(n, k, i + 1); // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始
    path.pop_back(); // 回溯，撤销处理的节点
}
```

---

## 代码

```cpp
class Solution {
public:
    vector<int> path; // 存放一组结果
    vector<vector<int>> result; // 存放所有结果

    void backtracking(int start, int n, int k){
        if(path.size() == k){
            result.push_back(path);
            return;
        } // 如果path中已经有了k个数，那么就是满足条件的一组组合，装入result

        // 若不满足则开始填充
        for(int i = start; i <= n; i++){ // !!注意这里条件要<=n，返回范围[1, n]
            path.push_back(i);
            backtracking(i+1, n, k); // 递归找下一个数
            path.pop_back(); // 找到满足条件的一组，回溯，弹出末尾的数重新找
        }
    }

    vector<vector<int>> combine(int n, int k) {
        path.clear();
        result.clear();
        backtracking(1, n, k);
        return result;
    }
};
```
